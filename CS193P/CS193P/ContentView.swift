import SwiftUI
// Model VievModel View парадигма конструирования для организации кода
//структуры по умолчанию являются открытыми только для чтения
struct ContentView:View {
//указатель на вью модель 
    @ObservedObject var viewModel :EmojiMemoryGame
    
    var body: some View
    //реализуем тело согласно протоколу вью это вычисляемая переменная при вызове происходит постоянное обновление не принимаем аргументов а используем функцию   
    {
        //экземпляр стуктуры грид берет массив карт по ссылке из вью модели в качестве аргумента вторым аргументом принимает функцию которая берет один единственный элемент и возвращает контент вью
        Grid(viewModel.cards)
        {
            //«Начало тела замыкания содержит ключевое слово in. Это ключевое слово указывает, что объявление параметров и возвращаемого значения замыкания закончено, и тело замыкания вот-вот начнется.»
            //каждая карта из массива возвращает экземпляр структуры кард вью с переданными аргументами карты и модифицированна функцией нажатия
            card in CardView(card: card).onTapGesture
            {
                //функция принимает свой экземпляр в аргументы возвращает в функцию вью модели карту
                self.viewModel.choose(card: card)
            }
            //эти функции прямо здесь модифируют view мы декларируем что именно это используется для рисования этого вью мы объявляем что именно эти особенности будут использоваться когда мы рисуем наше вью
            .padding(5)
        }
        .padding()
        .foregroundColor(Color.orange)
    }
}


struct CardView: View
//функцонирует как вью, ведет себя как вью
{
    //переменная карта будет указателем на карту из вью модель со строковым типом
    var card : MemoryGame<String>.Card
    //декларация переменной бади, реализация по протоколу вью не сохраняется в памяти она вычисляемая каждый запрос она вычисляется заново (frame)
    var body: some View
    
    {// реализация переменной возвращаем единественный контейнер
        ZStack
        {
            if card.isFaceUp
            {
                RoundedRectangle(cornerRadius: 0).fill(Color.clear)
                RoundedRectangle(cornerRadius: 15).stroke(lineWidth: 4)
                Text(card.content)
            }
            else
            {
                RoundedRectangle(cornerRadius: 15).fill()
            }
        }
    }
}





















struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(viewModel: EmojiMemoryGame())
    }
}
