
import SwiftUI
//структура грид с айтем и айтемвью не важно какого типа работает по протоколу вью где айтем обязательно идентифицируемый а айтемвью обязательно вью
//как работает эта структура
//при создании копии структуры мы указываем типа данных предметов и их вид при этом предметы соотвествуют протколу индентифицированния а их вид соотвествует протколу видов
//после мы создаем две переменных с предметами и функцией которая принимает предемет возвращает вью
//Чтобы выполняемое замыкание сохранилось после завершения функции, вы должны сохранить его в переменной, определенной вне функции.
struct Grid<Item, ItemView>: View where Item: Identifiable, ItemView: View {
    var items: [Item] //создаем переменный массивом предметов
    var viewForItem: (Item) -> ItemView // создаем функцию отрисовки предметов
    //при копировании структуры мы вызываем инициализатор передавая в аргументы необходимые для нас ресурсы
    //мы создаем свой инициализатор где обозначим какие переменные должны будут хранить аргументы переданные при инициализации
    init(_ items: [Item], viewForItem: @escaping (Item) -> ItemView) {
        //items присваивает себе значение переданного после инициализации аргумента
        //вторым аргументом мы передаем функцию которая консервируется в переменной до вызова, нам нужно хранить эту функцию на готове в куче но так как они указывают друг на друга мы должны предупредить об этом параметром escaping
        self.items = items
        self.viewForItem = viewForItem
    }
    var body : some View {
        //вычисляемая переменная тело соотвествует некоторому Виду
        //находим пространство для каждого объекта
        GeometryReader
        {
            //функция принимает аргументы а тело функции производит итерации по переденным аргументам айтем переменная структуры кстати говоря
            //«Начало тела замыкания содержит ключевое слово in. Это ключевое слово указывает, что объявление параметров и возвращаемого значения замыкания закончено, и тело замыкания вот-вот начнется.»
            geometry in
                self.body(for: GridLayout(itemCount: self.items.count, in: geometry.size))
        }
    }
    //функция принимает слой грид возвращает множество вью
    func body(for layout: GridLayout)-> some View
    {
        //цикл принимает айтемы из переменной структуры
        ForEach(items)
        {
            //берет каждый айтем 
            item in self.body(for: item, in: layout)
        }
    }
    // функция тело принимаем предмет, принимаем слойсетки возвращаем множество вью
    func body(for item: Item, in layout: GridLayout)-> some View{
        //Мы используем self., когда хотим подчеркнуть разницу между чем-то и тем, что является свойством или между функцией и локальной переменной или между параметром функции и свойством
        //константа индекса инициализированна результатом функции массива предметов  мы передали предемет для поиска по массиву и записали индекс в константу
        let index = items.FirstIndex(matching: item)!
        return viewForItem(item) //возвращаем в замыкание айтем
            .frame(width: layout.itemSize.width, height: layout.itemSize.height)
            .position(layout.location(ofItemAt: index))
    }
        //Ту же самую вещь мы можем сделать в нашем Grid, но нам не нужно выполнять Layout наших Views, это делается с помощью frame и position. То есть нам нужно что-то, что берет ViewBuilder в качестве аргумента и не делает ничего.
}
